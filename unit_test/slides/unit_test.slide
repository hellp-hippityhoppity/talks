Unit Testing
27 Oct 2015
Tags: go meetup, unit testing, standard library, go northeast

Nathan Davies
Software Engineer, Turnitin
ndavies@turnitin.com
@nathj07

* Scene Setting
- Very contrived code!
- Standard library only; testing package
- Start simple
- Refactor
- Table Based Tests
- Coverage
- Benchmarking

* Using the Standard Library
- Test Code
- Code to test
- Will drop to my shell run tests


* Some TDD 
.code ../code/conversation/conversation_test.go /^func TestGreeting/,/^}/
- Until the function is written this won't run
- Once written we prove the function defintion - signature and body
- t.Errorf: Allows the error to be reported but the code to continue in _this_ test function
- t.Fatalf: Reports the error and _stops_ this test function
- This is rudimentary, the very basis of red-to-green TDD

* The App Advances 
- Might be nice to have multi-lingual support
- Be nice to have more complex replies

* Take the TDD Path
.code ../code/conversation/conversation_test.go /START FR_ES/,/END FR_ES/

* Now the Function
.code ../code/conversation/conversation.go /^func GreetingV2/,/^}/
- The tests will pass - check it out with go test -v
- More languages = more test cases. Very tedious

* Refactor
- The previous tests are beneficial
- Also very repetitive
- Be better to have less repetition in tests
- Be nice if it were easier to add tests

* Table Based Testing
- Define a local scope test set
- Typically a slice of structs covering the inputs and outputs
.code ../code/conversation/conversation_test.go /START TABLE/,/END TABLE/

* The Test
.code ../code/conversation/conversation_test.go /^func TestGreetingV2All/,/^}/

* Benefits
- Adding more language support = add a new struct
- Test code is easy to read
- Test output is clear
- Coverage is clear from the code
- Tests are faster to write
- Bugs are easier to prove and fix (_demo_)

* My Typical Workflow
- Intial code
- Basic test
- More tests, more code
- check the coverage and race conditions as I go
- For bugs it's test to prove the fail
- Code to pass the test e.g. my work on govalidator (check the correct name)

* NEXT
- Benchmarking
- Example Tests

* Benchmarking
- Built in to the language
- No need to write timers and calculate ns/op
.code ../code/fibonacci/fibonacci.go

* The Test
.code ../code/fibonacci/fibonacci_test.go /^func BenchmarkGetnth/,/^}/
.code ../code/fibonacci/fibonacci.bench


* TODO
- Example Tests - super useful on Godoc
- Add a references section

* Extra features 
- coverage - _demo_ console and web report
- race - useful for finding some potential race conditions, particularly helpful in highly concurrent, long running applications
- Benchmarking - is particularly useful part of the standard, lets try that another day
- Libraries like go-convey and gocheck may be talked about next...

* Q&A